{
  "name": "socketpeer",
  "description": "simple 1:1 messaging via WebRTC Data Channels and WebSockets",
  "version": "1.0.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/cvan/socketpeer.git"
  },
  "bugs": {
    "url": "https://github.com/cvan/socketpeer/issues"
  },
  "dependencies": {
    "inherits": "^2.0.1",
    "simple-peer": "^4.0.2",
    "ws": "^0.7.1",
    "xtend": "^4.0.0"
  },
  "devDependencies": {
    "browserify": "^9.0.3",
    "nodemon": "^1.3.7",
    "onchange": "^1.0.0",
    "tape": "^3.5.0",
    "uglify-js": "^2.4.17",
    "zuul": "^2.1.1"
  },
  "keywords": [
    "webrtc",
    "p2p",
    "data channel",
    "data channels",
    "data",
    "peer",
    "stream",
    "peer-to-peer",
    "data channel stream",
    "webrtc stream",
    "peer",
    "websocket",
    "websockets",
    "socketpeer"
  ],
  "license": "MIT",
  "main": "server/index.js",
  "browser": "browser/index.js",
  "scripts": {
    "start": "NODE_ENVIRONMENT=production node server",
    "dev": "NODE_ENVIRONMENT=development nodemon server",
    "prod": "NODE_ENVIRONMENT=production node server",
    "build": "npm run browserify && npm run minify",
    "browserify": "browserify -s SocketPeer -r ./browser/ -o socketpeer.js",
    "minify": "uglifyjs socketpeer.js -c warnings=false -m > socketpeer.min.js",
    "watch": "npm run build && onchange browser/* -- npm run build",
    "test": "zuul -- test/*.js",
    "test-local": "zuul --local 3001 -- test/*.js"
  },
  "gitHead": "92804a4b0b568738fc3e0806a27aed615348f112",
  "readme": "# socketpeer\n\nSimple 1:1 messaging via WebRTC Data Channels and WebSockets.\n\n\n## Features\n\n* concise, Node.js-style API for **[WebRTC](https://en.wikipedia.org/wiki/WebRTC)**\n* simple 1:1 peer connection signalling, pairing, and messaging\n* fallback to WebSockets if WebRTC Data Channels are unsupported\n* automatic reconnection if peer connections prematurely close\n\nThis module works great in the browser with [browserify](http://browserify.org/).\n\n**NOTE:** If you are **not** using browserify, then use the included standalone file\n`socketpeer.min.js`. This exports a `SocketPeer` function on `window`.\n\n\n## Installation\n\nTo install from npm:\n\n    npm install socketpeer\n\nTo install the Node dependencies from the git repository:\n\n    npm install\n\n\n## Development\n\nTo run the browserify watcher (files are output to the `build/` directory):\n\n    npm run watch\n\nTo create the browserify bundles (files are output to the `build/` directory):\n\n    npm run build\n\n\n## Testing\n\nSet these up locally:\n\n* [Sauce Labs](https://github.com/defunctzombie/zuul/wiki/cloud-testing)\n* [Travis CI](https://github.com/defunctzombie/zuul/wiki/Travis-ci)\n\nTo run tests locally:\n\n    npm run test-local\n\nTo run tests in the cloud:\n\n    npm test\n\n\n## Client API\n\n### `peer = new SocketPeer([opts])`\n\nCreate a new peer WebRTC Data Channel peer connection (only WebRTC if `socketFallback` is `false`).\n\nA \"data channel\" for text/binary communication is always established, because it's cheap and often useful.\n\nIf `opts` is specified, then the default options (shown below) will be overridden.\n\n```js\n{\n  pairCode: '<random string>',\n  socketFallback: true,\n  socket: [Object],\n  url: 'http://localhost',\n  reconnect: true,\n  reconnectDelay: 1000,\n  timeout: 10000,\n  autoconnect: true,\n  serveLibrary: true,\n  debug: false\n}\n```\n\nThe options do the following:\n\n* `pairCode` - string used to identify peers\n* `socketFallback` - when `true`, falls back to WebSockets when WebRTC is unavailable\n* `socket` - custom instance of a WebSocket connection to reuse\n* `url` - URL to WebSocket server\n* `reconnect` - when `true`, reconnects if peer connection drops\n* `reconnectDelay` - if `reconnect` is set, how long to (ms) wait before reconnecting\n* `timeout` - how long to wait (ms) before abandoning connection\n* `autoconnect` - when `true`, automatically connects upon page load\n* `serveLibrary` - when `true`, serves library at `/socketpeer/socketpeer.js`\n* `debug` - when `true`, logs debugging information to the console\n\n### `peer.connect()`\n\nIf `reconnect` or `autoconnect` is `false`, manually start the connection.\n\n### `peer.send(data)`\n\nSend data to the remote peer.\n\n### `peer.on(event, listener)`\n\nAdds a listener to the end of the listeners array for the specified `event`.\n\n### `peer.off(event)`\n\nRemove listeners for the specified `event`.\n\nSocketPeer extends Node's [`EventEmitter`](https://nodejs.org/api/events.html). See the docs for the remaining methods.\n\n### `peer.close()`\n\nDestroy and cleanup this peer connection.\n\n\n## Events\n\n### `peer.on('connect', function () {})`\n\nFired when the peer connection and/or data channel is established.\n\n### `peer.on('connect_error', function (data) {})`\n\nFired when a connection error occurs.\n\n### `peer.on('connect_timeout', function (data) {})`\n\nFired when a connection timeout occurs.\n\n### `peer.on('data', function (data) {})`\n\nReceived a message from the remote peer.\n\n### `peer.on('disconnect', function () {})`\n\nFired when the peer connection is lost.\n\n### `peer.on('reconnect', function (data) {})`\n\nFired when a reconnection occurs.\n\n### `peer.on('reconnect_error', function (data) {})`\n\nFired when a reconnection error occurs.\n\n### `peer.on('reconnect_timeout', function (data) {})`\n\nFired when a reconnection timeout occurs.\n\n### `peer.on('upgrade', function (data) {})`\n\nFired when a connection is successfully upgraded from WebSocket to RTCDataChannel.\n\n### `peer.on('upgrade_attempt', function (data) {})`\n\nFired when an upgrade attempt occurs.\n\n### `peer.on('upgrade_error', function (data) {})`\n\nFired when an upgrade error occurs.\n\n### `peer.on('downgrade', function (data) {})`\n\nFired when a connection falls back to WebSockets.\n\n### `peer.on('close', function () {})`\n\nCalled when the peer connection has closed.\n\n### `peer.on('busy', function (err) {})`\n\nFired when two clients are already connected using a same pair code. `err` is an `Error` object.\n\n### `peer.on('error', function (err) {})`\n\nFired when an error occurs. `err` is an `Error` object.\n\n\n## Server API\n\n### `peerServer = new SocketPeerServer([opts])`\n\nCreate a new server for establishing peer connections (i.e., \"signalling\") and passing WebSocket messages through (if WebRTC Data Channel not supported).\n\nIf `httpServer` is specified, that existing server will be used instead and a `ws.Server` will be created and attached to it. To use an existing `ws.Server` for signalling, pass `wsServer`.\n\nIf `opts` is specified, then the default options (shown below) will be overridden.\n\n```js\n{\n  allowedOrigins: [Array],\n  httpServer: undefined,\n  wsServer: undefined,\n  peerTimeout: 60000,\n  pairCodeValidator: function (pairCode) {}\n}\n```\n\nThe options do the following:\n\n* `allowedOrigins` - array of allowed origins (optional)\n* `peerTimeout` - how long to wait before abandoning peer connection (defaults to 6000 ms, 1 minute)\n* `pairCodeValidator` - function that allows custom validation on the `pairCode` passed from the client (optional)\n\n### `peerServer.socket`\n\nA property that links to the instance of [**`ws.Server`**](https://github.com/websockets/ws).\n\n### `peerServer.server`\n\nA property that links to the instance of `http.Server`.\n\n### `peerServer.leave(pairCode)`\n\nBreaks both ends of a peer connection (WebSocket or WebRTC).\n\n\n## Licence\n\n[MIT Licence](LICENCE)\n\n\n## Contributing\n\n[Contributions are very welcome!](CONTRIBUTING.md)\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/cvan/socketpeer#readme",
  "_id": "socketpeer@1.0.2",
  "_shasum": "2d550e2ed30949a6586c116ae6f0d886a0a89153",
  "_from": "donmccurdy/socketpeer#fork-master",
  "_resolved": "git://github.com/donmccurdy/socketpeer.git#92804a4b0b568738fc3e0806a27aed615348f112"
}
